---
title: "initR: Exercices/Questions"
output:
  learnr::tutorial:
    progressive: false
    allow_skip: true
runtime: shiny_prerendered
css: "www/styles.css"
---

```{r setup, include=FALSE}
library(learnr)
library(gradethis)
gradethis_setup()
options(
  # gradethis_glue_correct = "{ random_praise() } { .message } { .correct }",
  gradethis_glue_correct = "{ .message } { .correct }",  
  # gradethis_glue_incorrect = "{ .message } { .incorrect } { random_encourage() }"
  gradethis_glue_incorrect = "{ .message } { .incorrect }"
)
knitr::opts_chunk$set(echo = FALSE)
```

Ce document rassemble un certain nombre d'exercices, qui sont de **deux types**.

- Des exercices de type **QCM**.
- Des exercices de type **code**.

Dans ce deuxième type d'exercice, vous pourrez **modifier du code** dans une fenêtre (fond jaune pâle) qui est l'équivalent d'un **éditeur** (très simplifié) de code R. Pour **exécuter** les lignes de code, vous pouvez vous placer dessus et faire **Ctrl+Enter**. Le résultat s'affichera dans une fenêtre (fond rose pâle) en-dessous qui est l'équivalent d'une **console** R.

```{r decouvre_exos, exercise=TRUE}
a=33
b=29
a=22
a
```

```{r decouvre_exos-check}
grade_result(~pass_if(~identical(a,22),"Très bien! Le 'résultat' du code correspond bien à la valeur 22"),
             ~pass_if(~!identical(a,22),"Ah non! le 'résultat' du code ne correspond pas à la valeur attendue..."))
```


Le code que vous entrerez peut être évalué automatiquement lorsque vous appuyez sur **Submit solution**. 

L'évaluation porte usuellement sur la dernière commande écrite dans l'éditeur (celle écrite tout en bas!), ainsi que (plus généralement) sur le fait que le code ne génère pas d'erreur lors de son exécution.

Par exemple, l'exercice ci-dessus est paramétré pour être évalué comme correct quand la dernière commande (donc d'après le code pré-renseigné l'objet `a`) correspond à la valeur 22, et incorrect autrement... Vous pouvez corriger (ou non) le code dans l'éditeur pour tester le comportement de l'évaluation...




## 1. Introduction 

![](www/grimoire.png){width=70px}<a href="http://perso.ens-lyon.fr/lise.vaudor/Supports_formation/initR_0_introduction.html#(1)" target="_blank">Cliquer ici pour les diapos de cours</a>

### 1.1 Usages de R

```{r usages_R}
question("Que pouvez-vous faire avec R?",
    answer("Des modèles", correct=TRUE),
    answer("Des simulations", correct=TRUE),
    answer("Des statistiques", correct=TRUE),
    answer("Du café"),
    answer("Des graphiques", correct=TRUE),
    answer("Des rapports", correct = TRUE),
    answer("Des pains au chocolat"),
    answer("Des diaporamas", correct=TRUE),
    incorrect="Seules deux de ces propositions ne sont pas correctes",
    correct="Oui! C'est dommage pour le café mais il faut bien une motivation pour se lever de son fauteuil de temps en temps...",
    allow_retry=TRUE
)
```

### 1.2 Usages de RStudio

```{r usages_RStudio}
question("Quelles propositions sont vraies?",
    answer("RStudio remplace R",),
    answer("RStudio complète R", correct=TRUE),
    answer("RStudio est un outil essentiel pour travailler avec R", correct=TRUE),
    answer("RStudio est un gadget qui rend l'usage de R plus amusant"),
    answer("RStudio est gratuit", correct=TRUE),
    answer("RStudio est payant"),
    incorrect="Nope! Qu'avez-vous installé pour ce cours? RStudio seul ou RStudio ET R? Avez-vous eu à payer une licence?",
    correct="Oui! RStudio complète R en rendant son usage beaucoup plus simple et convivial, et il est gratuit... C'est l'IDE de référence pour l'usage de R.",
    allow_retry=TRUE
)
```

### 1.3 Assignation

Testez les commandes suivantes. 

Modifiez le code **pour que `obj_d` fasse également partie de l'environnement** et soit listé lors de l'appel de `ls()`.


```{r assignation, exercise=TRUE, exercise.lines=8}
obj_a <- "coin-coin"
obj_b <- "pouet-pouet"
obj_c = 25.7
#obj_d <- 33
ls()
```

```{r assignation-solution}
obj_a <- "coin-coin"
obj_b <- "pouet-pouet"
obj_c = 25.7
obj_d <- 33
ls()
```

```{r assignation-check}
grade_result(
  fail_if(~isFALSE("obj_d" %in% .result), "Non, l'objet obj_d ne fait toujours pas partie de l'environnement"),
  pass_if(~isTRUE("obj_d" %in% .result),
          "Eh oui! Avant que vous dé-commentiez la ligne, le vecteur `obj_d` n'était pas créé."),
  fail_if(~ TRUE, "ça fonctionne pas"),
  learnr_args = list(last_value = ls())

)
```


## 2. Objets de base 

![](www/grimoire.png){width=70px}<a href="http://perso.ens-lyon.fr/lise.vaudor/Supports_formation/initR_1_objets_de_base.html#(1)" target="_blank">Cliquer ici pour les diapos de cours</a>

### 2.1 Création de vecteurs

Le code suivant crée quatre vecteurs. **Examinez-les** et répondez à la question suivante

```{r cree_vecteurs, exercise=TRUE, exercise.lines=6}
vec1 <- 0:5
vec2 <- seq(0,5,length.out=5)
vec3 <- c("0","1","2","3","4","5")
vec4 <- seq(0,5,by=1)
```

```{r question_vecteurs}
question("Quelle est la proposition correcte?",
    answer("Tous les vecteurs ont un contenu identique"),
    answer("vec1 et vec4 ont un contenu identique", correct=TRUE),
    answer("vec1, vec3 et vec4 ont un contenu identique"),
    answer("vec1, vec2 et vec4 ont un contenu identique"),
    incorrect="Examinez bien les objets... Leur longueur... la présence de guillemets...",
    correct="Oui, bravo! Avez-vous remarqué comme avec R il faut faire attention aux subtilités comme l'usage de guillemets?...",
    allow_retry=TRUE
)
```


### 2.2 Création d'une tibble

Complétez le code ci-dessous pour créer la tibble `starks` qui résume quelques données sur des personnages de la série Game of Thrones.

Précisez le nom de famille de Jon (à savoir "Snow") et en complétez la variable "Age" (numérique) correspondant aux âges des enfants Stark (respectivement 15, 14, 11, 9, 7 et 3 ans).

```{r,cree_tibble-setup}
library(dplyr)
```

```{r cree_tibble, exercise=TRUE, exercise.lines=6}
starks <- tibble(FirstName=c("Robb","Jon","Sansa","Arya","Brandon","Rickon"),
                 LastName=c("Stark",_,"Stark","Stark","Stark","Stark"),
                 Age=c(_,_,_,_,_,_),
                 Direwolf=c("Grey Wind","Ghost","Lady","Nymeria","Summer","Shaggydog"))     
```

```{r cree_tibble-solution}
starks <- tibble(FirstName=c("Robb","Jon","Sansa","Arya","Brandon","Rickon"),
                 LastName=c("Stark","Snow","Stark","Stark","Stark","Stark"),
                 Age=c(15,14,11,9,7,3),
                 Direwolf=c("Grey Wind","Ghost","Lady","Nymeria","Summer","Shaggydog"))
```


```{r cree_tibble-check}
grade_code("Impec!")
```

### 2.3 Indexation des vecteurs

```{r index_vec-setup}
set.seed(33)
vec <- c("Marseille","Lyon","Toulouse","Paris","Bordeaux")
vecvilles <- sample(vec,1000,replace=T)
```

```{r index_vec, exercise=TRUE, exercise.lines=3}
vecvilles
```

```{r question_index_vec}
question("Quel est le 567ème élément de vecvilles?",
         answer("Marseille"),
         answer("Lyon"),
         answer("Paris", correct=TRUE),
         answer("Bordeaux"),
         incorrect="Non! Utilisez le système d'indexation: vecvilles[567] vous renvoie le 567ème élément du vecteur.",
         correct="Oui! vecvilles[567] vous renvoie le 567ème élément du vecteur, qui ici se trouve être 'Paris'.")
```

### 2.4 Indexation d'une liste

L'environnement contient une liste `ma_liste`. En utilisant le système d'indexation des objets de type liste, récupérez le 4ème élément de l'élément fruits dans l'objet ma_liste.

```{r, index_list-setup}
ma_liste=list(fruits=c("bananes","pommes","cerises","poires","abricots"),
              legumes=c("chou-fleur","poivron","carotte","poireau","brocoli","haricot","fenouil"),
              feculents=c("riz","pâtes","pommes de terre","semoule"))
```

```{r index_list, exercise=TRUE, exercise.lines=4}
quatrieme_fruit <- ___
quatrieme_fruit
```

```{r index_list-solution}
quatrieme_fruit <- ma_liste$fruits[4]
quatrieme_fruit
```

```{r index_list-check}
grade_code("Bravo! Retenez l'usage des `$` pour récupérer les éléments nommés et des crochets `[...]` pour récupérer les éléments non-nommés!")
```



### 2.5 Indexation d'une tibble

L'environnement contient une tibble `ma_tibble`. En utilisant le système d'indexation des objets de type tibble, récupérez les sixième et septième éléments de la variable `cri` dans cette tibble.

```{r index_tib-setup}
library(dplyr)

ma_tibble=tibble(animal=c("chat","chien","âne","cheval","coq","cochon","vache"),
                 cri=c("miaou!","ouaf-ouaf!","hi-han!","hiihiiiihiiiii!","cocoricoo!","grouik!","meuh!"))
```

```{r index_tib, exercise=TRUE, exercise.lines=4}
sixieme_et_septieme_cris <-___
sixieme_et_septieme_cris
```

```{r index_tib-solution}
sixieme_et_septieme_cris <- ma_tibble$cri[6:7]
sixieme_et_septieme_cris
```

```{r index_tib-check}
grade_code("Bravo! Retenez l'usage des `$` pour récupérer les éléments nommés et des crochets `[...]` pour récupérer les éléments non-nommés!")
```


## 3. Opérateurs, fonctions et packages

![](www/grimoire.png){width=70px}<a href="http://perso.ens-lyon.fr/lise.vaudor/Supports_formation/initR_2_operateurs_et_fonctions.html#(1)" target="_blank">Cliquer ici pour les diapos de cours</a>


### 3.1 Opérateurs arithmétiques

Le script ci-dessous crée deux vecteurs, `pommes` et `bananes`. 

Complétez le script pour **créer un nouveau vecteur** `fruits` qui correspond à la **somme** (élément par élément) des pommes et des bananes.

<small>Ne réécrivez pas le vecteur fruits à la main! Il faut simplement ici réaliser une opération arithmétique simple à l'aide des vecteurs `pommes` et `bananes`...</small>

```{r ope_arith, exercise=TRUE, exercise.lines=5}
bananes <- c(5, 2, 3, 1, 7 , 8,NA, 2)
pommes <-  c(2, 1, 0, 2, NA, 3, 1, 5)
fruits <- _______________
```

```{r ope_arith-solution}
bananes <- c(5, 2, 3, 1, 7 , 8,NA, 2)
pommes <-  c(2, 1, 0, 2, NA, 3, 1, 5)
fruits <- pommes + bananes
```

```{r ope_arith-check}
grade_code("Oui! Avez-vous remarqué comme NA+quelque chose donne NA?...")
```


### 3.2 Opérateurs logiques

```{r ope_logiques}
question("Sachant que x<-33,laquelle de ces propositions renvoie FALSE?",
         answer("x>10 | x>50"),
         answer("x>=30 & x<=1000", correct=TRUE),
         answer("x>30 & x<10"),
         answer("x %in% c(11,22,33,44,55)"),
         answer("x<40"),
         incorrect="Eh oui! on ne peut pas avoir à la fois x>30 et x<10 donc quelle que soit la valeur de x, cette proposition est forcément fausse!",
         correct="En effet...")
```

Gardez à l'esprit que (prop1 & prop2) est vraie si les **deux** propositions sont vraies; en revanche (prop1 | prop2) est vraie si **au moins l'une des deux** propositions est vraie...

### 3.3 Usage d'une fonction

L'environnement contient un vecteur `x`. Calculez la **moyenne**, la **variance**, et le **quantile d'ordre 90%** du vecteur `x`. 

<small>Pensez au préalable à convertir la valeur 90% en une valeur comprise entre 0 et 1...</small>

```{r use_f-setup}
set.seed(33)
x=rnorm(1000,3,2)
```

```{r use_f, exercise=TRUE, exercise.lines=6}
moyenne <- ___
variance <- ___
quantile90p <- ___
```

```{r, use_f-solution}
moyenne <- mean(x)
variance <- var(x)
quantile90p=quantile(x,0.9)
```

```{r use_f-check}
grade_code("Parfait!")
```


### 3.4 Arguments d'une fonction

La fonction `mean()` renvoie la moyenne d'un vecteur. L'existence d'un élément manquant (NA) dans le vecteur cause le renvoi de NA comme résultat.

Un des **arguments** de `mean()` permet de changer ce comportement pour renvoyer la moyenne du vecteur en **omettant les NA**.

Trouvez le nom de cet argument en consultant l'**aide de la fonction** et complétez la deuxième commande (ci-contre) pour calculer `m2`.

Remarque: vous pouvez consulter le fichier d'aide associé à la fonction depuis la console, comme vous le feriez depuis RStudio...

```{r arg_fonction, exercise=TRUE, exercise.lines=6}
vec <- c(3,2,8,NA,6,8,10,4,12,21,NA)

m1 <- mean(vec)
m2 <- mean(vec, _____)
```

```{r arg_fonction-solution}
vec <- c(3,2,8,NA,6,8,10,4,12,21,NA)

m1 <- mean(vec)
m2 <- mean(vec, na.rm=T)
```

Avez-vous consulté l'aide de la fonction mean() (en tapant par exemple help(mean) ou ?mean) pour trouver le nom de l'argument qui nous intéresse ici?

```{r arg_fonction-check}
grade_code("Très bien! Si l'on est assez facilement au clair sur ce que fait la fonction 'mean()', il y aura sans doute, à l'avenir, de nombreuses fonctions pour lesquelles vous aurez grand besoin de consulter l'aide!")
```

![](www/grimoire.png){width=70px}<a href="http://perso.ens-lyon.fr/lise.vaudor/Supports_formation/initR_2b_packages.html#(1)" target="_blank">Cliquer ici pour les diapos de cours sur les packages</a>

### 3.5 Charger un package

L'environnement contient la tibble `starks`.

On veut utiliser la fonction `filter()` du package `dplyr`. 

Examinez l'erreur renvoyée par le code ci-contre et **complétez-le** pour que l'on parvienne à utiliser cette fonction et que le code ne génère plus d'erreur.

```{r, load_dplyr-setup}
starks <- dplyr::tibble(FirstName=c("Robb","Jon","Sansa","Arya","Brandon","Rickon"),
                 LastName=c("Stark","Snow","Stark","Stark","Stark","Stark"),
                 Age=c(15,14,11,9,7,3),
                 Direwolf=c("Grey Wind","Ghost","Lady","Nymeria","Summer","Shaggydog"))
```

```{r load_dplyr,exercise=TRUE, exercise.lines=6}
filter(starks, LastName=="Stark")
```

```{r load_dplyr-solution}
library(dplyr)
filter(starks, LastName=="Stark")
```

```{r load_dplyr-check}
grade_code("Très bien! La fonction `filter()` n'était pas connue car le package n'avait pas été chargé... (En revanche, il était déjà installé!)")
```


## 4. Tableaux de données

![](www/grimoire.png){width=70px}<a href="http://perso.ens-lyon.fr/lise.vaudor/Supports_formation/initR_4_tableaux_de_donnees.html#(1)" target="_blank">Cliquer ici pour les diapos de cours</a>
### 4.1 Lire une tibble

![](www/potions.png){width=70px}Dans la suite des exercices concernant la manipulation de tableaux de données nous allons utiliser le tableau `potions` disponible <a href="http://perso.ens-lyon.fr/lise.vaudor/Supports_formation/initR_4_tableaux_de_donnees.html#(1)" target="_blank">ici</a>.

Utilisez la fonction `read_csv()` ou `read_delim()`(du package `readr`) pour lire cette table et assignez-la à un objet `catdata`.


```{r read_tib-setup}
library(readr)
path="http://perso.ens-lyon.fr/lise.vaudor/Rdata/Graphiques_avec_ggplot2/catdata.csv"
```

```{r read_tib, exercise=TRUE, exercise.lines=6}
potions <- readr::read_delim("http://perso.ens-lyon.fr/lise.vaudor/grimoireStat/datasets/potions.csv",
                             delim=";")
catdata
```

success_msg("Oui, bravo! Dans mon fichier catdata.csv, le séparateur de colonnes était un point-virgule, et non une virgule comme attendu par `read_csv()`. Mieux valait donc passer par `read_delim()`")

### 4.2 Sélectionner des colonnes

La fonction `select()` permet de sélectionner des colonnes d'un tableau de données.

Le tableau `catdata` et le package `dplyr` ont déjà été chargés dans l'environnement ci-contre.

Examinez la table `catdata`. Complétez le code pour sélectionner :

- les variables `weight`, `foodtype`, et `age`
- toutes les variables SAUF `foodtype` et `sex`
- toutes les variables de `haircolor` à `weight`
- toutes les variables qui commencent par le motif "hair", à l'aide de `starts_with()`

Pour dire "de haircolor à weight", vous pouvez utiliser la notation suivante: haircolor:weight.

```{r select_tib-setup}
catdata=readr::read_delim("http://perso.ens-lyon.fr/lise.vaudor/Rdata/Graphiques_avec_ggplot2/catdata.csv",
                          delim=";")
library(dplyr)
```

```{r, select_tib, exercise=TRUE, exercise.lines=20}
#les variables `weight`, `foodtype`, et `age`
dat1 <- select(catdata,_______)
dat1
#toutes les variables SAUF `foodtype` et `sex`
dat2 <- select(_______________)
dat2
#toutes les variables de `haircolor` à `weight`
dat3 <- ______(_______________)
dat3
#toutes les variables qui commencent par le motif `hair`, à l'aide de `starts_with()`
dat4 <- _______________________
dat4
```

```{r, select_tib-solution}
#les variables `weight`, `foodtype`, et `age`
dat1 <- select(catdata, weight, foodtype, age)
dat1
#toutes les variables SAUF `foodtype` et `sex`
dat2 <- select(catdata, - foodtype, -sex)
dat2
#toutes les variables de `haircolor` à `weight`
dat3 <- select(catdata, haircolor:weight)
dat3
#toutes les variables qui commencent par le motif `hair`, à l'aide de `starts_with()`
dat4 <- select(catdata,starts_with("hair"))
dat4
```

success_msg("C'est ça! Vous avez compris le truc pour sélectionner facilement des variables de votre jeu de données.")

### 4.3 Filtrer des lignes

Le tableau `catdata` et le package `dplyr` ont déjà été chargés dans l'environnement ci-dessous.

Examinez la table `catdata`. Complétez le code pour filtrer les lignes et ne garder que:

- les chats dont le **poil est roux** (data_roux)
- les chats **particulièrement gros** (7 kilos ou plus) ou **particulièrement** vieux (15 ans ou plus) (data_gros_ou_vieux)

Avez-vous bien fait attention à la différence entre la comparaison stricte (< ou >) et la comparaison "ou égal" (>= ou <=)?

```{r filter_tib-setup}
potions=readr::read_delim("http://perso.ens-lyon.fr/lise.vaudor/Rdata/Graphiques_avec_ggplot2/catdata.csv",
                          delim=";")
library(dplyr)
```

```{r filter_tib, exercise=TRUE, exercise.lines=8}
data_roux <- _____
data_roux

data_gros_ou_vieux <- _____
data_gros_ou_vieux
```

```{r filter_tib-solution}
data_roux <- filter(catdata,haircolor=="red")
data_roux

data_gros_ou_vieux <- filter(catdata, weight>=7 | age>=15)
data_gros_ou_vieux
```

success_msg("Bravo! Vous savez maintenant filtrer les lignes d'un jeu de données.")

### 4.4 Arranger les lignes

La fonction `arrange()` permet de réordonner les lignes d'un tableau.

Le tableau `catdata` et le package `dplyr` ont déjà été chargés dans l'environnement ci-contre.

Complétez le code pour réarranger les tableaux par

- poids
- sexe
- sexe et âge
- sexe et âge décroissant

Pensez à utiliser la **fonction auxiliaire** `desc()` pour ranger les valeurs dans l'ordre décroissant.

```{r arrange_tib-setup}
catdata=readr::read_delim("http://perso.ens-lyon.fr/lise.vaudor/Rdata/Graphiques_avec_ggplot2/catdata.csv",
                          delim=";")
library(dplyr)
```

```{r arrange_tib, exercise=TRUE, exercise.lines=10}
data_par_poids <- arrange(catdata,_____)

data_par_sexe  <- arrange(_____________)

data_par_sexe_et_age <-  _____(_________________)

data_par_sexe_et_age_decr <- ___________________________
```

```{r, arrange_tib-solution}
data_par_poids <- arrange(catdata,weight)

data_par_sexe <- arrange(catdata,sex)

data_par_sexe_et_age <- arrange(catdata,sex,age)

data_par_sexe_et_age_decr <- arrange(catdata,sex,desc(age))
```

success_msg("Oui! Vous allez pouvoir bien ranger vos données...")

### 4.5 Transformer le tableau

La fonction `mutate()` permet de créer et ajouter de nouvelles variables à un tableau.

Le tableau `catdata` et les packages `dplyr` et `stringr` ont déjà été chargés dans l'environnement ci-contre.

Complétez le code pour créer de nouvelles variables:

- dans `data_plus_age_humain`, la nouvelle variable age_humain sera l'"âge équivalent humain" du chat (i.e. son âge multiplié par 7).
- dans `data_plus_hair`, la nouvelle variable hair correspondra à la couleur et au type de pelage (par exemple, pour un chat "red",et "tabby", hair aura pour valeur "red-tabby"). Pour cela, vous pourrez utiliser la fonction `str_c()` du package stringr qui concatène des chaînes de caractère.

```{r mutate_tib-setup}
catdata=readr::read_delim("http://perso.ens-lyon.fr/lise.vaudor/Rdata/Graphiques_avec_ggplot2/catdata.csv",
                          delim=";")
library(dplyr)
library(stringr)
```


```{r mutate_tib, exercise=TRUE, exercise.lines=10}
data_plus_age_humain <- ______________________

# juste pour vous montrer comment fonctionne la fonction `str_c()`
vdemo=c("pouet","coin")
str_c(vdemo,"-",vdemo)

data_plus_hair <- mutate(catdata,hair=_____)
```

```{r mutate_tib-solution}
data_plus_age_humain <- mutate(catdata,age_humain=age*7)

data_plus_hair <- mutate(catdata,hair=str_c(haircolor,"-",hairpattern))
```



```{r mutate_tib-check}
grade_code("Oui... avez-vous vu le chat vénérable qui a 119 ans-humains?")
```

### 4.6 Résumer l'information

La fonction `summarise()` permet de résumer l'information contenue dans un tableau, éventuellement groupe par groupe (groupes définis à l'aide de la fonction auxiliaire `group_by()`).

Le tableau `catdata` et le package `dplyr` ont déjà été chargés dans l'environnement ci-contre.

Complétez le code pour créer de nouveaux tableaux résumant une partie de l'information contenue dans `catdata`.

Pensez à la différence entre les fonctions auxiliaires `n()` et `n_distinct()`.

```{r summary_tib-setup}
catdata=readr::read_delim("http://perso.ens-lyon.fr/lise.vaudor/Rdata/Graphiques_avec_ggplot2/catdata.csv",
                          delim=";")
library(dplyr)
```

```{r summary_tib, exercise=TRUE, exercise.lines=22}
moy <- summarise(catdata,
                 moy_poids=_______,
                 moy_age=_______)

# groupes definis par sex et haircolor
# calculer moyenne de poids et moyenne d'age
moy_par_groupe <- _________(group_by(catdata,_________),
                            moy_poids=__________,
                            moy_age=________)

# groupes definies par sex et haircolor, calculer le minimum et maximum de poids
# calculer nombre total d'individus, calculer le nombre de motifs de poils (hairpattern) distincts dans ces groupes
resume_par_groupe <- summarise(_______________________),
                               min_poids=__________,
                               max_poids=__________,
                               nbre_individus=______,
                               nbre_motifs=_________
                               
```


```{r summary_tib-solution}
moy <- summarise(catdata,
                 moy_poids=mean(weight),
                 moy_age=mean(age))

# groupes definis par sex et haircolor
# calculer moyenne de poids et moyenne d'age
moy_par_groupe <- summarise(group_by(catdata,sex,haircolor),
                            moy_poids=mean(weight),
                            moy_age=mean(age))

# groupes definies par sex et haircolor, calculer le minimum et maximum de poids
# calculer nombre total d'individus, calculer le nombre de motifs de poils (hairpattern) distincts dans ces groupes
resume_par_groupe <- summarise(group_by(catdata,sex,haircolor),
                               min_poids=min(weight),
                               max_poids=max(weight),
                               nbre_individus=n(),
                               nbre_motifs=n_distinct(hairpattern)
```


```{r summary_tib-check}
grade_code("Bien vu! Puissante, la fonction `summarise`, non?")
```


### 4.7 Chaînage

L'utilisation de l'opérateur pipe (`%>%`) permet d'enchaîner plusieurs opérations de dplyr.

La table catdata compte **153 lignes** et **6 colonnes**, et comporte **18 chat roux qui mangent des croquettes**.

```{r}
catdata=readr::read_delim("http://perso.ens-lyon.fr/lise.vaudor/Rdata/Graphiques_avec_ggplot2/catdata.csv",
                          delim=";")
library(dplyr)
```


```{r, echo=TRUE}
data <- catdata %>% select(sex,haircolor,weight,foodtype) %>% filter(haircolor=="red",foodtype=="dry")
```

```{r dim_tib}
question("Etes vous capable de prédire quelle seront les dimensions du tableau data résultant de la commande suivante?",
         answer("135 lignes et 4 colonnes"),
         answer("18 lignes et 6 colonnes"),
         answer("18 lignes et 4 colonnes", correct=TRUE),
         answer("153 lignes et 4 colonnes"),
         correct="",
         incorrect="Réfléchissez bien à l'enchaînement des opérations... on prend catdata, puis on sélectionne les variables sex, haircolor,weight et foodtype, puis on filtre les lignes pour ne garder que les chats roux qui mangent des croquettes",
         allow_retry=TRUE)
```

### 4.8 Chaînage: on enchaîne, on enchaîne!

Le tableau `catdata` et le package `dplyr` ont déjà été chargés dans l'environnement ci-contre.

Complétez le script ci-contre:

Pour construire `dat1`, on prend catdata, puis on filtre pour ne garder que les chats noirs, puis on sélectionne les colonnes pour ne garder que `haircolor`, `weight`, et `age`, puis on arrange la table par ordre décroissant de `weight` et ordre croissant de `age`.

Pour construire `dat2`, on prend catdata, puis on ne filtre pour ne garder que les chats qui pèsent strictement moins de 5 kilos, puis on groupe par couleur de poil, puis on résume l'information en calculant moy_age, la moyenne d'âge par groupe.

Pensez qu'en utilisant les `%>%` vous n'avez plus besoin de passer de table en premier argument...

```{r chainchain-setup}
catdata=readr::read_delim("http://perso.ens-lyon.fr/lise.vaudor/Rdata/Graphiques_avec_ggplot2/catdata.csv",
                          delim=";")
library(dplyr)
```

```{r chainchain, exercise=TRUE, exercise.lines=12}
dat1 <- catdata %>%
  ______(______) %>%
  ______(______) %>%
  ______(______)

dat2 <- catdata %>%
  ______(______) %>%
  ______(______) %>%
  ______(______)
```

```{r chainchain-solution}
dat1 <- catdata %>%
  filter(haircolor=="black") %>%
  select(haircolor,weight,age) %>%
  arrange(desc(weight), age)

dat2 <- catdata %>%
  filter(weight<5) %>%
  group_by(haircolor) %>%
  summarise(moy_age=mean(age))
```

```{r chainchain-check}
grade_code("Bravo! Vous voilà prêts à triturer vos tableaux de données à qui mieux-mieux!")
```


## 5. Graphiques

![](www/grimoire.png){width=70px}<a href="http://perso.ens-lyon.fr/lise.vaudor/Supports_formation/initR_5_graphiques_introduction.html#(1)" target="_blank">Cliquer ici pour les diapos de cours</a>

### 5.1 Premier graphique: histogramme simple

On considère le jeu de données `diamonds`, fourni par la librairie `ggplot2`.

Examinez le jeu de données `diamonds`.

Complétez le code ci-dessous pour tracer l'histogramme correspondant au prix des diamants (couleur de remplissage: `blue`).


```{r simple_hist, exercise=TRUE, exercise.lines=9}
library(ggplot2)
data(diamonds)
head(diamonds)
p <- ggplot(_____, aes(x=____)) +
  geom_histogram(fill=_____)

plot(p)
```

```{r simple_hist-solution}
library(ggplot2)
data(diamonds)
head(diamonds)

p <- ggplot(diamonds, aes(x=price)) +
  geom_histogram(fill="blue")
plot(p)
```

Avez-vous bien spécifié le nom du tableau de données (`diamonds`, sans guillemets), le nom de la variable (`price`, sans guillemets) et la valeur du paramètre `fill` ("blue")?

```{r simple_hist-check}
grade_code("Bien joué! vous avez fait votre premier graphique avec ggplot...")
```

### 5.2 Choix de geom

On considère le jeu de données `diamonds`. Ce jeu de données est fourni avec le package `ggplot2` et vous pouvez le charger dans la console en chargeant le package puis le jeu de données.

```{r show_diamonds, exercise=TRUE}
library(ggplot2)
data(diamonds)
str(diamonds)
```

Examinez les données et répondez à la question suivante. 

```{r choix_geom}
question("Quel geom est le plus approprié si je souhaite tracer price (y) en fonction de depth (x)?",
         answer("un geom de type point", correct=TRUE),
         answer("un geom de type histogram"),
         answer("un geom de type boxplot"),
         correct="Oui, les deux variables sont numériques donc le nuage de point est tout indiqué...",
         incorrect="Les variables sont toutes deux numériques et continues...",
         allow_retry=TRUE)
```

### 5.3 Geoms en tous genres

`ggplot2` et `diamonds` ont déjà été chargés.

Complétez le code pour créer:

- p1, un **nuage de points** montrant `price` (y) en fonction de `carat` (x)
- p2, un **boxplot** montrant `price` (y) en fonction de `cut` (x)
- p3, un **barplot** (`geom_bar()`) montrant les effectifs de `cut` (x)

Il y a à chaque fois 3 éléments importants à spécifier: le jeu de données, les variables x et (éventuellement) y, et la nature du geom!

```{r tous_geoms, exercise=TRUE, exercise.lines=17}
# Graphique p1
p1 <- ggplot(diamonds, aes(x=___, y=___)) +
   ____()
plot(p1)

# Graphique p2
p2 <- ggplot(___________________________) +
  ______()
plot(p2)

# Graphique p3
p3 <- ______________________________________
  _____________
plot(p3)
```

```{r tous_geoms-setup}
require(ggplot2)
data(diamonds)
```

```{r tous_geoms-solution}
# Graphique p1
p1 <- ggplot(diamonds, aes(x=carat, y=price)) +
   geom_point()
plot(p1)

# Graphique p2
p2 <- ggplot(diamonds, aes(x=cut, y=price)) +
  geom_boxplot()
plot(p2)

# Graphique p3
p3 <- ggplot(diamonds, aes(x=cut)) +
  geom_bar()
plot(p3)
```

```{r tous_geoms-check}
grade_code("Bien! Il y a encore bien d'autres geoms disponibles, mais `point` et `boxplot` sont des incontournables...")
```

### 5.4 Paramétrer des geoms

`ggplot2` et `diamonds` ont déjà été chargés.

On a repris les 3 graphiques créés précédemment, mais cette fois on souhaite **paramétrer les geoms**. Complétez le code pour que

- dans `p1`, les points soient bleus
- dans `p2`, l'intérieur des boîtes soit rouge
- dans `p3`, les barres soient transparentes (à 50%)

Avez-vous bien trouvé le nom des paramètres qui vous intéressent?

- `color` pour la **couleur de bordure**,
- `fill` pour la **couleur de remplissage**,
- `alpha` (valeurs entre 0 et 1) pour la **transparence**...


```{r params_geoms, exercise=TRUE, exercise.lines=16}
p1 <- ggplot(diamonds, aes(x=carat, y=price)) +
   geom_point(___)
plot(p1)

# Graphique p2
p2 <- ggplot(diamonds, aes(x=cut, y=price)) +
  geom_boxplot(___)
plot(p2)

# Graphique p3
p3 <- ggplot(diamonds, aes(x=cut)) +
  geom_bar(____)
plot(p3)
```

```{r params_geoms-setup}
require(ggplot2)
require(dplyr)
data(diamonds)
```

```{r params_geoms-solution}
# Graphique p1
p1 <- ggplot(diamonds, aes(x=carat, y=price)) +
   geom_point(color="blue")
plot(p1)

# Graphique p2
p2 <- ggplot(diamonds, aes(x=cut, y=price)) +
  geom_boxplot(fill="red")
plot(p2)

# Graphique p3
p3 <- ggplot(diamonds, aes(x=cut)) +
  geom_bar(alpha=0.5)
plot(p3)
```


```{r params_geoms-check}
grade_code("Bien joué! Quelle joie, vous allez pouvoir customiser tous vos graphiques en rose!")
```

### 5.5 Superposer des geoms

`ggplot2` et `diamonds` ont déjà été chargés.

Complétez le code pour représenter la variable table du jeu de données `diamonds` en **superposant deux geoms**:

- un geom de type **histogram**, et de couleur de **remplissage jaune**
- un geom de type **rug**

```{r superpose_geoms-setup}
require(ggplot2)
require(dplyr)
data(diamonds)
```

```{r superpose_geoms, exercise=TRUE, exercise.lines=6}
p<-_____________________+
  _______________+
  ___________
plot(p)
```

```{r superpose_geoms-solution}
p <- ggplot(diamonds, aes(x=table)) +
  geom_histogram(fill="yellow") +
  geom_rug()
plot(p)
```

```{r superpose_geoms-check}
grade_code("Bravo! Vous êtes en bonne voie pour faire des graphiques vraiment sympas!...")
```

### 5.6 Mapping

`ggplot2` et `diamonds` ont déjà été chargés.

Complétez le code ci- contre pour que:

- `p1`, `p2` et `p3` soient trois **nuages de points** représentant le **prix** (`price`, en y) en fonction du **nombre de carats** (`carat`, en x)
- la couleur du `geom_point()` de `p1` corresponde à la coupe des diamants (variable `cut`)
- la taille du `geom_point()` de `p2` corresponde à la table des diamants(variable `table`)
- les **deux conditions précédentes soient remplies** pour le `geom_point()` de `p3`

```{r mapping-setup}
require(ggplot2)
data(diamonds)
```

```{r mapping, exercise=TRUE}
p1 <- ggplot(diamonds, aes(x=___, y=___)) +
  geom_point(aes(____))
plot(p1)

p2 <- ggplot(________, aes(_____________))+
  geom_point(_________)
plot(p2)

p3 <- ggplot(____________________________)+
   ________(__________)
plot(p3)
```

```{r mapping-solution}
p1 <- ggplot(diamonds, aes(x=carat, y=price)) +
  geom_point(aes(color=cut))
plot(p1)

p2 <- ggplot(diamonds, aes(x=carat, y=price))+
  geom_point(aes(size=table))
plot(p2)

p3 <- ggplot(diamonds, aes(x=carat, y=price))+
  geom_point(aes(size=table, color=cut))
plot(p3)
```

```{r mapping-check}
grade_code("Très bien! En faisant du mapping vous ajoutez des informations supplémentaires à votre graphique uni ou bivarié...")
```

### 5.7 Paramètres fixes vs paramètres variables

`ggplot2` et `diamonds` ont déjà été chargés. On reprend le dernier graphique créé, p3.

Modifiez le code ci-dessous pour que la **forme des points** corresponde à un **carré plein** (voir l'antisèche ggplot2...)

<small> Si vous définissez le paramètre comme une constante, vous devez le spécifier à l'extérieur de la fonction aes()... </small>

```{r paramsfixes-setup}
library(ggplot2)
data(diamonds)
```

```{r paramsfixes, exercise=TRUE, exercise.lines=6}
p3 <- ggplot(diamonds, aes(x=carat, y=price))+
  geom_point(aes(size=table, color=cut))
plot(p3)
```

```{r paramsfixes-solution}
p3 <- ggplot(diamonds, aes(x=carat, y=price))+
  geom_point(shape=15, aes(size=table, color=cut))
plot(p3)
```

```{r paramsfixes-check}
grade_code("Oui! Vous pouvez soit définir les paramètres des geoms comme des constantes, ou bien les relier à des variables via le processus de mapping...")
```

### 5.8 Esthétique globale ou propre à un geom

Considérez les lignes de codes suivantes:

```{r params, exercise=TRUE, exercise.lines=6}
p <- ggplot(diamonds, aes(x=cut, y=carat, color=cut))+
  geom_boxplot(fill="grey") +
  geom_rug()
plot(p)
```

```{r question-params}
question("Quelle proposition est vraie?",
         answer("la couleur de remplissage des boxplots dépend de cut"),
         answer("la couleur des 'rugs' est grise"),
         answer("la couleur de bordure des boxplots est grise"),
         answer("la couleur de remplissage des boxplots est grise", correct=TRUE),
         correct="Exact. La couleur de remplissage des boxplots est grise, la couleur de bordure dépend quant à elle de `cut`.",
         incorrect="Non! Attention à la distinction entre `fill` et `color`, ainsi qu'à la différence entre paramètres fixes et paramètres fixés par `aes()`",
         allow_retry=TRUE)
```


### 5.9 Ajustement de la position

`ggplot2` et `diamonds` ont déjà été chargés.

Examinez le code ci-dessous et le graphique qu'il renvoie.

Corrigez ce code pour que les effectifs des différentes coupes apparaissent les uns à côté des autres (paramètre position... consultez votre antisèche!!)

Vous pouvez voir les valeurs possibles pour ce paramètre sur votre antisèche ggplot (2ème page, "Position Adjustments")

<small> Attention, le paramètre de position n'est pas une esthétique...</small>

```{r graphique_position-setup}
library(ggplot2)
data(diamonds)
```

```{r graphique_position, exercise=TRUE}
p <- ggplot(diamonds, aes(x=carat))+
  geom_histogram(bins=10,aes(fill=cut))
plot(p)
```

```{r, graphique_position-solution}
p <- ggplot(diamonds, aes(x=carat))+
  geom_histogram(bins=10, position="dodge",aes(fill=cut))
plot(p)
```

```{r graphique_position-check}
grade_code("Oui! Avez-vous pris le temps pour bien comprendre comment le paramètre `position` modifiait la façon dont on peut lire le graphique?")
```

### 5.10 Facettes

`ggplot2` et `diamonds` ont déjà été chargés.

Complétez le code ci-contre pour produire **différentes facettes** du même graphique en fonction de la **coupe des diamants** (5 lignes, 1 colonne)

<small> Faites en sorte que les facettes soient en ligne et non en colonne dans l'appel à la fonction facet_grid()... </small>

```{r facettes-setup}
require(ggplot2)
data(diamonds)
```

```{r facettes, exercise=TRUE}
p <- ggplot(diamonds, aes(x=carat, y=price, color=cut)) +
  geom_point() +
  ____________
plot(p)
```

```{r facettes-solution}
p <- ggplot(diamonds, aes(x=carat, y=price, color=cut)) +
  geom_point() +
  facet_grid(rows=vars(cut))
plot(p)
```

```{r facettes-check}
grade_code("Eh oui, bien joué! Les facettes , c'est trop de la boule :-) !")
```


### 5.11 Etiquettes et transformation d'axes

`ggplot2` et `diamonds` ont déjà été chargés.

Modifiez le code ci-contre pour que:

- les **étiquettes d'axes** soient "coupe" (en x) et "prix" (en y)
- l'**échelle des y** soit transformée par une transformation `log10`
- les **valeurs de l'axe **x soient traduites (en "Correcte","Bonne","Tres bonne","Premium","Ideale")

Consultez l'antisèche ggplot2!!!

```{r etiqu_transfo-setup}
require(ggplot2)
data(diamonds)
```

```{r, etiqu_transfo, exercise=TRUE}
p <- ggplot(diamonds, aes(x=cut, y=price)) +
  geom_boxplot(fill="pink") +
  _______ +
  _______ +
  _______
plot(p)
```

```{r etiqu_transfo-solution}
p <- ggplot(diamonds, aes(x=cut, y=price)) +
  geom_boxplot(fill="pink") +
  labs(x="coupe",y="prix") +
  scale_y_log10() +
  scale_x_discrete(labels=c("Correcte","Bonne","Tres bonne","Premium","Ideale"))
plot(p)
```

```{r etiqu_transfo-check}
grade_code("Très bien! Vous savez maintenant customiser vos axes!!")
```

### 5.12 Echelles de couleurs

Imaginons que je souhaite produire un **nuage de points** montrant **`carat` en fonction de `cut`**, en faisant varier **la couleur en fonction de `price`**.

```{r echelle_coloree}
question("Quelle fonction devrais-je utiliser pour éventuellement modifier l'échelle colorée? (consultez l'antisèche ggplot2!)",
         answer("scale_color_brewer()"),
         answer("scale_fill_brewer()"),
         answer("scale_color_gradient()", correct=TRUE),
         answer("scale_fill_gradient()"),
         correct="Oui, bravo! Retenez cette solution pour l'exercice suivant...",
         incorrect="`brewer` s'applique à des échelles discrètes, or `price` est une variable continue, de plus on s'intéresse à une couleur de bordure et non à une couleur de remplissage",
         allow_retry=TRUE)
```

### 5.13 Thème et échelle de couleur

`ggplot2` et `diamonds` ont déjà été chargés, et un graphique produit.

Modifiez le code qui vous est fourni ci-contre pour reproduire cette figure.

Il s'agit de

- modifier le **thème**
- modifier l'**échelle colorée** pour que les **prix les plus bas** correspondent à la couleur **jaune** et les **prix les plus hauts** à la couleur **bleue**.

```{r, echo=FALSE}
library(ggplot2)
data(diamonds)
p <-ggplot(diamonds, aes(x=cut, y=carat,color=price))+
  geom_jitter() +
  theme_minimal()+
  scale_color_gradient(low="yellow",high="blue")
plot(p)
```


```{r, reproduit_fig, exercise=TRUE}
p <-ggplot(diamonds, aes(x=cut, y=carat,color=price))+
  geom_jitter() +
  __________()+
  __________(_______)
plot(p)
```


```{r, reproduit_fig-solution}
p <-ggplot(diamonds, aes(x=cut, y=carat,color=price))+
  geom_jitter() +
  theme_minimal()+
  scale_color_gradient(low="yellow",high="blue")
plot(p)
```



```{r reproduit_fig-check}
grade_code("Bravo! C'est de toute beauté!")
```


### 5.14 Rajout d'un nuage de points montrant les moyennes

`ggplot2`, `dplyr` et `diamonds` ont déjà été chargés.

Complétez le code ci-contre pour rajouter des **points bleus** montrant les **moyennes de prix** (donc moyennes de y) **par coupe de diamant**.

```{r points_moy-setup}
library(ggplot2)
library(dplyr)
data(diamonds)
```

```{r points_moy, exercise=TRUE}
df_moyprix <- diamonds %>%
     ____ %>%
     ____

p <- ggplot(diamonds, aes(x=cut, y=price)) +
  geom_boxplot(fill="pink")+
  geom_point(___________)
plot(p)
```

```{r points_moy-solution}
df_moyprix <- diamonds %>%
     group_by(cut) %>%
     summarise(moyprix=mean(price))

p <- ggplot(diamonds, aes(x=cut, y=price)) +
  geom_boxplot(fill="pink")+
  geom_point(data=df_moyprix,
             aes(y=moyprix),
             color="blue")
plot(p)
```

```{r points_moy-check}
grade_code("Parfait! Comme vous pouvez le constater, le prix d'un diamant est peu corrélé à la perfection de sa coupe!")
```

### 5.15 Des facettes par milliers?

Examinez le code suivant (sans l'exécuter!):

```{r}
p <- ggplot(diamonds, aes(x=carat, y=price)) +
  geom_point(aes(color=cut), alpha=0.1)+
  geom_smooth(method="lm", aes(linetype=clarity))
plot(p)
```



```{r combien_de_reg}
question("Au vu de ces commandes, combien de droites de régression s'attendrait-on à voir sur le graphique correspondant?",
         answer("5, autant que de niveaux de cut"),
         answer("8, autant que de niveaux de clarity", correct=TRUE),
         answer("1, i.e. un modèle global pour l'ensemble des données"),
         answer("40, i.e. le nombre de niveaux de cut multiplié par le nombre de niveaux de clarity"),
         correct="En effet! 8 niveaux, cela fait un graphique déjà bien assez chargé comme ça!!",
         incorrect="Ouhla, non! `cut` ne joue que sur la couleur des points,  et `clarity` fait partie des esthétiques de `geom_smooth`.",
         allow_retry=TRUE)
```

## Projets et rapports

